From fb1db2a12c96d66c9a182db321cba01c208c331d Mon Sep 17 00:00:00 2001
From: Ismo Puustinen <ismo.puustinen@intel.com>
Date: Fri, 28 Oct 2016 13:32:18 +0300
Subject: [PATCH] iptables: added support for iptables locking.

Currently iptables subsystem doesn't allow multiple processes to manage
iptables rules at the same time. The "iptables" userspace binary has
locking to prevent this. Make connman use the same flock schema that
"iptables" uses in order to prevent race conditions.

Signed-off-by: Ismo Puustinen <ismo.puustinen@intel.com>
---
 src/firewall.c | 40 ++++++++++++++++++++++++++++++++++++++++
 1 file changed, 40 insertions(+)

diff --git a/src/firewall.c b/src/firewall.c
index c440df6..8e3bab5 100644
--- a/src/firewall.c
+++ b/src/firewall.c
@@ -24,6 +24,8 @@
 #endif
 
 #include <errno.h>
+#include <sys/file.h>
+#include <unistd.h>
 
 #include <xtables.h>
 #include <linux/netfilter_ipv4/ip_tables.h>
@@ -62,6 +64,7 @@ static GSList *managed_tables;
 
 static bool firewall_is_up;
 static unsigned int firewall_rule_id;
+static int lock_fd = -1;
 
 static int chain_to_index(const char *chain_name)
 {
@@ -375,6 +378,11 @@ int __connman_firewall_enable_rule(struct firewall_context *ctx, int id)
 	GList *list;
 	int err = -ENOENT;
 
+	if (flock(lock_fd, LOCK_EX | LOCK_NB) != 0) {
+		err = -EWOULDBLOCK;
+		goto error;
+	}
+
 	for (list = g_list_first(ctx->rules); list; list = g_list_next(list)) {
 		rule = list->data;
 
@@ -388,6 +396,12 @@ int __connman_firewall_enable_rule(struct firewall_context *ctx, int id)
 		}
 	}
 
+	if (flock(lock_fd, LOCK_UN | LOCK_NB) != 0) {
+		close(lock_fd);
+		lock_fd = -1;
+	}
+
+error:
 	return err;
 }
 
@@ -398,6 +412,11 @@ int __connman_firewall_disable_rule(struct firewall_context *ctx, int id)
 	int e;
 	int err = -ENOENT;
 
+	if (flock(lock_fd, LOCK_EX | LOCK_NB) != 0) {
+		err = -EWOULDBLOCK;
+		goto error;
+	}
+
 	for (list = g_list_last(ctx->rules); list;
 			list = g_list_previous(list)) {
 		rule = list->data;
@@ -416,6 +435,12 @@ int __connman_firewall_disable_rule(struct firewall_context *ctx, int id)
 		}
 	}
 
+	if (flock(lock_fd, LOCK_UN | LOCK_NB) != 0) {
+		close(lock_fd);
+		lock_fd = -1;
+	}
+
+error:
 	return err;
 }
 
@@ -529,8 +554,18 @@ int __connman_firewall_init(void)
 {
 	DBG("");
 
+	lock_fd = open("/run/xtables.lock", O_CREAT, 0600);
+
+	if (flock(lock_fd, LOCK_EX | LOCK_NB) != 0)
+		return -EWOULDBLOCK;
+
 	flush_all_tables();
 
+	if (flock(lock_fd, LOCK_UN | LOCK_NB) != 0) {
+		close(lock_fd);
+		lock_fd = -1;
+	}
+
 	return 0;
 }
 
@@ -539,4 +574,9 @@ void __connman_firewall_cleanup(void)
 	DBG("");
 
 	g_slist_free_full(managed_tables, cleanup_managed_table);
+
+	if (lock_fd >= 0) {
+		close(lock_fd);
+		lock_fd = -1;
+	}
 }
-- 
2.7.4

